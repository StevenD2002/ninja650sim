/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.3
 * source: motorcycle.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace motorcycle {
    export class EngineData extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            rpm?: number;
            throttle_position?: number;
            timestamp?: number;
            power?: number;
            torque?: number;
            engine_temp?: number;
            afr_current?: number;
            afr_target?: number;
            fuel_injection_ms?: number;
            ignition_advance?: number;
            gear?: number;
            speed?: number;
            clutch_position?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("rpm" in data && data.rpm != undefined) {
                    this.rpm = data.rpm;
                }
                if ("throttle_position" in data && data.throttle_position != undefined) {
                    this.throttle_position = data.throttle_position;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("power" in data && data.power != undefined) {
                    this.power = data.power;
                }
                if ("torque" in data && data.torque != undefined) {
                    this.torque = data.torque;
                }
                if ("engine_temp" in data && data.engine_temp != undefined) {
                    this.engine_temp = data.engine_temp;
                }
                if ("afr_current" in data && data.afr_current != undefined) {
                    this.afr_current = data.afr_current;
                }
                if ("afr_target" in data && data.afr_target != undefined) {
                    this.afr_target = data.afr_target;
                }
                if ("fuel_injection_ms" in data && data.fuel_injection_ms != undefined) {
                    this.fuel_injection_ms = data.fuel_injection_ms;
                }
                if ("ignition_advance" in data && data.ignition_advance != undefined) {
                    this.ignition_advance = data.ignition_advance;
                }
                if ("gear" in data && data.gear != undefined) {
                    this.gear = data.gear;
                }
                if ("speed" in data && data.speed != undefined) {
                    this.speed = data.speed;
                }
                if ("clutch_position" in data && data.clutch_position != undefined) {
                    this.clutch_position = data.clutch_position;
                }
            }
        }
        get rpm() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set rpm(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get throttle_position() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set throttle_position(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set timestamp(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get power() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set power(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get torque() {
            return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
        }
        set torque(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get engine_temp() {
            return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
        }
        set engine_temp(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get afr_current() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set afr_current(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get afr_target() {
            return pb_1.Message.getFieldWithDefault(this, 8, 0) as number;
        }
        set afr_target(value: number) {
            pb_1.Message.setField(this, 8, value);
        }
        get fuel_injection_ms() {
            return pb_1.Message.getFieldWithDefault(this, 9, 0) as number;
        }
        set fuel_injection_ms(value: number) {
            pb_1.Message.setField(this, 9, value);
        }
        get ignition_advance() {
            return pb_1.Message.getFieldWithDefault(this, 10, 0) as number;
        }
        set ignition_advance(value: number) {
            pb_1.Message.setField(this, 10, value);
        }
        get gear() {
            return pb_1.Message.getFieldWithDefault(this, 11, 0) as number;
        }
        set gear(value: number) {
            pb_1.Message.setField(this, 11, value);
        }
        get speed() {
            return pb_1.Message.getFieldWithDefault(this, 12, 0) as number;
        }
        set speed(value: number) {
            pb_1.Message.setField(this, 12, value);
        }
        get clutch_position() {
            return pb_1.Message.getFieldWithDefault(this, 13, 0) as number;
        }
        set clutch_position(value: number) {
            pb_1.Message.setField(this, 13, value);
        }
        static fromObject(data: {
            rpm?: number;
            throttle_position?: number;
            timestamp?: number;
            power?: number;
            torque?: number;
            engine_temp?: number;
            afr_current?: number;
            afr_target?: number;
            fuel_injection_ms?: number;
            ignition_advance?: number;
            gear?: number;
            speed?: number;
            clutch_position?: number;
        }): EngineData {
            const message = new EngineData({});
            if (data.rpm != null) {
                message.rpm = data.rpm;
            }
            if (data.throttle_position != null) {
                message.throttle_position = data.throttle_position;
            }
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            if (data.power != null) {
                message.power = data.power;
            }
            if (data.torque != null) {
                message.torque = data.torque;
            }
            if (data.engine_temp != null) {
                message.engine_temp = data.engine_temp;
            }
            if (data.afr_current != null) {
                message.afr_current = data.afr_current;
            }
            if (data.afr_target != null) {
                message.afr_target = data.afr_target;
            }
            if (data.fuel_injection_ms != null) {
                message.fuel_injection_ms = data.fuel_injection_ms;
            }
            if (data.ignition_advance != null) {
                message.ignition_advance = data.ignition_advance;
            }
            if (data.gear != null) {
                message.gear = data.gear;
            }
            if (data.speed != null) {
                message.speed = data.speed;
            }
            if (data.clutch_position != null) {
                message.clutch_position = data.clutch_position;
            }
            return message;
        }
        toObject() {
            const data: {
                rpm?: number;
                throttle_position?: number;
                timestamp?: number;
                power?: number;
                torque?: number;
                engine_temp?: number;
                afr_current?: number;
                afr_target?: number;
                fuel_injection_ms?: number;
                ignition_advance?: number;
                gear?: number;
                speed?: number;
                clutch_position?: number;
            } = {};
            if (this.rpm != null) {
                data.rpm = this.rpm;
            }
            if (this.throttle_position != null) {
                data.throttle_position = this.throttle_position;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            if (this.power != null) {
                data.power = this.power;
            }
            if (this.torque != null) {
                data.torque = this.torque;
            }
            if (this.engine_temp != null) {
                data.engine_temp = this.engine_temp;
            }
            if (this.afr_current != null) {
                data.afr_current = this.afr_current;
            }
            if (this.afr_target != null) {
                data.afr_target = this.afr_target;
            }
            if (this.fuel_injection_ms != null) {
                data.fuel_injection_ms = this.fuel_injection_ms;
            }
            if (this.ignition_advance != null) {
                data.ignition_advance = this.ignition_advance;
            }
            if (this.gear != null) {
                data.gear = this.gear;
            }
            if (this.speed != null) {
                data.speed = this.speed;
            }
            if (this.clutch_position != null) {
                data.clutch_position = this.clutch_position;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.rpm != 0)
                writer.writeDouble(1, this.rpm);
            if (this.throttle_position != 0)
                writer.writeDouble(2, this.throttle_position);
            if (this.timestamp != 0)
                writer.writeInt64(3, this.timestamp);
            if (this.power != 0)
                writer.writeDouble(4, this.power);
            if (this.torque != 0)
                writer.writeDouble(5, this.torque);
            if (this.engine_temp != 0)
                writer.writeDouble(6, this.engine_temp);
            if (this.afr_current != 0)
                writer.writeDouble(7, this.afr_current);
            if (this.afr_target != 0)
                writer.writeDouble(8, this.afr_target);
            if (this.fuel_injection_ms != 0)
                writer.writeDouble(9, this.fuel_injection_ms);
            if (this.ignition_advance != 0)
                writer.writeDouble(10, this.ignition_advance);
            if (this.gear != 0)
                writer.writeInt32(11, this.gear);
            if (this.speed != 0)
                writer.writeDouble(12, this.speed);
            if (this.clutch_position != 0)
                writer.writeDouble(13, this.clutch_position);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): EngineData {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new EngineData();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.rpm = reader.readDouble();
                        break;
                    case 2:
                        message.throttle_position = reader.readDouble();
                        break;
                    case 3:
                        message.timestamp = reader.readInt64();
                        break;
                    case 4:
                        message.power = reader.readDouble();
                        break;
                    case 5:
                        message.torque = reader.readDouble();
                        break;
                    case 6:
                        message.engine_temp = reader.readDouble();
                        break;
                    case 7:
                        message.afr_current = reader.readDouble();
                        break;
                    case 8:
                        message.afr_target = reader.readDouble();
                        break;
                    case 9:
                        message.fuel_injection_ms = reader.readDouble();
                        break;
                    case 10:
                        message.ignition_advance = reader.readDouble();
                        break;
                    case 11:
                        message.gear = reader.readInt32();
                        break;
                    case 12:
                        message.speed = reader.readDouble();
                        break;
                    case 13:
                        message.clutch_position = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): EngineData {
            return EngineData.deserialize(bytes);
        }
    }
    export class UserInput extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            throttle_position?: number;
            clutch_position?: number;
            gear?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("throttle_position" in data && data.throttle_position != undefined) {
                    this.throttle_position = data.throttle_position;
                }
                if ("clutch_position" in data && data.clutch_position != undefined) {
                    this.clutch_position = data.clutch_position;
                }
                if ("gear" in data && data.gear != undefined) {
                    this.gear = data.gear;
                }
            }
        }
        get throttle_position() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set throttle_position(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get clutch_position() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set clutch_position(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get gear() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set gear(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            throttle_position?: number;
            clutch_position?: number;
            gear?: number;
        }): UserInput {
            const message = new UserInput({});
            if (data.throttle_position != null) {
                message.throttle_position = data.throttle_position;
            }
            if (data.clutch_position != null) {
                message.clutch_position = data.clutch_position;
            }
            if (data.gear != null) {
                message.gear = data.gear;
            }
            return message;
        }
        toObject() {
            const data: {
                throttle_position?: number;
                clutch_position?: number;
                gear?: number;
            } = {};
            if (this.throttle_position != null) {
                data.throttle_position = this.throttle_position;
            }
            if (this.clutch_position != null) {
                data.clutch_position = this.clutch_position;
            }
            if (this.gear != null) {
                data.gear = this.gear;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.throttle_position != 0)
                writer.writeDouble(1, this.throttle_position);
            if (this.clutch_position != 0)
                writer.writeDouble(2, this.clutch_position);
            if (this.gear != 0)
                writer.writeInt32(3, this.gear);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UserInput {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UserInput();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.throttle_position = reader.readDouble();
                        break;
                    case 2:
                        message.clutch_position = reader.readDouble();
                        break;
                    case 3:
                        message.gear = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UserInput {
            return UserInput.deserialize(bytes);
        }
    }
    export class MapRow extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            values?: number[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
        }
        get values() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as number[];
        }
        set values(value: number[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            values?: number[];
        }): MapRow {
            const message = new MapRow({});
            if (data.values != null) {
                message.values = data.values;
            }
            return message;
        }
        toObject() {
            const data: {
                values?: number[];
            } = {};
            if (this.values != null) {
                data.values = this.values;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.values.length)
                writer.writePackedDouble(1, this.values);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapRow {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapRow();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.values = reader.readPackedDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapRow {
            return MapRow.deserialize(bytes);
        }
    }
    export class Map2D extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            type?: string;
            rpm_breakpoints?: number[];
            load_breakpoints?: number[];
            values?: MapRow[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("rpm_breakpoints" in data && data.rpm_breakpoints != undefined) {
                    this.rpm_breakpoints = data.rpm_breakpoints;
                }
                if ("load_breakpoints" in data && data.load_breakpoints != undefined) {
                    this.load_breakpoints = data.load_breakpoints;
                }
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set type(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get rpm_breakpoints() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as number[];
        }
        set rpm_breakpoints(value: number[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get load_breakpoints() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as number[];
        }
        set load_breakpoints(value: number[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get values() {
            return pb_1.Message.getRepeatedWrapperField(this, MapRow, 4) as MapRow[];
        }
        set values(value: MapRow[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        static fromObject(data: {
            type?: string;
            rpm_breakpoints?: number[];
            load_breakpoints?: number[];
            values?: ReturnType<typeof MapRow.prototype.toObject>[];
        }): Map2D {
            const message = new Map2D({});
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.rpm_breakpoints != null) {
                message.rpm_breakpoints = data.rpm_breakpoints;
            }
            if (data.load_breakpoints != null) {
                message.load_breakpoints = data.load_breakpoints;
            }
            if (data.values != null) {
                message.values = data.values.map(item => MapRow.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                type?: string;
                rpm_breakpoints?: number[];
                load_breakpoints?: number[];
                values?: ReturnType<typeof MapRow.prototype.toObject>[];
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.rpm_breakpoints != null) {
                data.rpm_breakpoints = this.rpm_breakpoints;
            }
            if (this.load_breakpoints != null) {
                data.load_breakpoints = this.load_breakpoints;
            }
            if (this.values != null) {
                data.values = this.values.map((item: MapRow) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type.length)
                writer.writeString(1, this.type);
            if (this.rpm_breakpoints.length)
                writer.writePackedDouble(2, this.rpm_breakpoints);
            if (this.load_breakpoints.length)
                writer.writePackedDouble(3, this.load_breakpoints);
            if (this.values.length)
                writer.writeRepeatedMessage(4, this.values, (item: MapRow) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Map2D {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Map2D();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readString();
                        break;
                    case 2:
                        message.rpm_breakpoints = reader.readPackedDouble();
                        break;
                    case 3:
                        message.load_breakpoints = reader.readPackedDouble();
                        break;
                    case 4:
                        reader.readMessage(message.values, () => pb_1.Message.addToRepeatedWrapperField(message, 4, MapRow.deserialize(reader), MapRow));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Map2D {
            return Map2D.deserialize(bytes);
        }
    }
    export class ECUMaps extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            fuel_map?: Map2D;
            ignition_map?: Map2D;
            afr_map?: Map2D;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fuel_map" in data && data.fuel_map != undefined) {
                    this.fuel_map = data.fuel_map;
                }
                if ("ignition_map" in data && data.ignition_map != undefined) {
                    this.ignition_map = data.ignition_map;
                }
                if ("afr_map" in data && data.afr_map != undefined) {
                    this.afr_map = data.afr_map;
                }
            }
        }
        get fuel_map() {
            return pb_1.Message.getWrapperField(this, Map2D, 1) as Map2D;
        }
        set fuel_map(value: Map2D) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_fuel_map() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get ignition_map() {
            return pb_1.Message.getWrapperField(this, Map2D, 2) as Map2D;
        }
        set ignition_map(value: Map2D) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_ignition_map() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get afr_map() {
            return pb_1.Message.getWrapperField(this, Map2D, 3) as Map2D;
        }
        set afr_map(value: Map2D) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_afr_map() {
            return pb_1.Message.getField(this, 3) != null;
        }
        static fromObject(data: {
            fuel_map?: ReturnType<typeof Map2D.prototype.toObject>;
            ignition_map?: ReturnType<typeof Map2D.prototype.toObject>;
            afr_map?: ReturnType<typeof Map2D.prototype.toObject>;
        }): ECUMaps {
            const message = new ECUMaps({});
            if (data.fuel_map != null) {
                message.fuel_map = Map2D.fromObject(data.fuel_map);
            }
            if (data.ignition_map != null) {
                message.ignition_map = Map2D.fromObject(data.ignition_map);
            }
            if (data.afr_map != null) {
                message.afr_map = Map2D.fromObject(data.afr_map);
            }
            return message;
        }
        toObject() {
            const data: {
                fuel_map?: ReturnType<typeof Map2D.prototype.toObject>;
                ignition_map?: ReturnType<typeof Map2D.prototype.toObject>;
                afr_map?: ReturnType<typeof Map2D.prototype.toObject>;
            } = {};
            if (this.fuel_map != null) {
                data.fuel_map = this.fuel_map.toObject();
            }
            if (this.ignition_map != null) {
                data.ignition_map = this.ignition_map.toObject();
            }
            if (this.afr_map != null) {
                data.afr_map = this.afr_map.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_fuel_map)
                writer.writeMessage(1, this.fuel_map, () => this.fuel_map.serialize(writer));
            if (this.has_ignition_map)
                writer.writeMessage(2, this.ignition_map, () => this.ignition_map.serialize(writer));
            if (this.has_afr_map)
                writer.writeMessage(3, this.afr_map, () => this.afr_map.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ECUMaps {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ECUMaps();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.fuel_map, () => message.fuel_map = Map2D.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.ignition_map, () => message.ignition_map = Map2D.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.afr_map, () => message.afr_map = Map2D.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ECUMaps {
            return ECUMaps.deserialize(bytes);
        }
    }
    export class MapsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data: {}): MapsRequest {
            const message = new MapsRequest({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapsRequest {
            return MapsRequest.deserialize(bytes);
        }
    }
    export class MapUpdateRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            map_type?: string;
            rpm?: number;
            load?: number;
            value?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("map_type" in data && data.map_type != undefined) {
                    this.map_type = data.map_type;
                }
                if ("rpm" in data && data.rpm != undefined) {
                    this.rpm = data.rpm;
                }
                if ("load" in data && data.load != undefined) {
                    this.load = data.load;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get map_type() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set map_type(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get rpm() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set rpm(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get load() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set load(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set value(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            map_type?: string;
            rpm?: number;
            load?: number;
            value?: number;
        }): MapUpdateRequest {
            const message = new MapUpdateRequest({});
            if (data.map_type != null) {
                message.map_type = data.map_type;
            }
            if (data.rpm != null) {
                message.rpm = data.rpm;
            }
            if (data.load != null) {
                message.load = data.load;
            }
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                map_type?: string;
                rpm?: number;
                load?: number;
                value?: number;
            } = {};
            if (this.map_type != null) {
                data.map_type = this.map_type;
            }
            if (this.rpm != null) {
                data.rpm = this.rpm;
            }
            if (this.load != null) {
                data.load = this.load;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.map_type.length)
                writer.writeString(1, this.map_type);
            if (this.rpm != 0)
                writer.writeDouble(2, this.rpm);
            if (this.load != 0)
                writer.writeDouble(3, this.load);
            if (this.value != 0)
                writer.writeDouble(4, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapUpdateRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapUpdateRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.map_type = reader.readString();
                        break;
                    case 2:
                        message.rpm = reader.readDouble();
                        break;
                    case 3:
                        message.load = reader.readDouble();
                        break;
                    case 4:
                        message.value = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MapUpdateRequest {
            return MapUpdateRequest.deserialize(bytes);
        }
    }
    export class ECUSettings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            fuel_trim?: number;
            ignition_trim?: number;
            idle_rpm?: number;
            rev_limit?: number;
            temp_compensation?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fuel_trim" in data && data.fuel_trim != undefined) {
                    this.fuel_trim = data.fuel_trim;
                }
                if ("ignition_trim" in data && data.ignition_trim != undefined) {
                    this.ignition_trim = data.ignition_trim;
                }
                if ("idle_rpm" in data && data.idle_rpm != undefined) {
                    this.idle_rpm = data.idle_rpm;
                }
                if ("rev_limit" in data && data.rev_limit != undefined) {
                    this.rev_limit = data.rev_limit;
                }
                if ("temp_compensation" in data && data.temp_compensation != undefined) {
                    this.temp_compensation = data.temp_compensation;
                }
            }
        }
        get fuel_trim() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set fuel_trim(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get ignition_trim() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set ignition_trim(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get idle_rpm() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set idle_rpm(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get rev_limit() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set rev_limit(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get temp_compensation() {
            return pb_1.Message.getFieldWithDefault(this, 5, false) as boolean;
        }
        set temp_compensation(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            fuel_trim?: number;
            ignition_trim?: number;
            idle_rpm?: number;
            rev_limit?: number;
            temp_compensation?: boolean;
        }): ECUSettings {
            const message = new ECUSettings({});
            if (data.fuel_trim != null) {
                message.fuel_trim = data.fuel_trim;
            }
            if (data.ignition_trim != null) {
                message.ignition_trim = data.ignition_trim;
            }
            if (data.idle_rpm != null) {
                message.idle_rpm = data.idle_rpm;
            }
            if (data.rev_limit != null) {
                message.rev_limit = data.rev_limit;
            }
            if (data.temp_compensation != null) {
                message.temp_compensation = data.temp_compensation;
            }
            return message;
        }
        toObject() {
            const data: {
                fuel_trim?: number;
                ignition_trim?: number;
                idle_rpm?: number;
                rev_limit?: number;
                temp_compensation?: boolean;
            } = {};
            if (this.fuel_trim != null) {
                data.fuel_trim = this.fuel_trim;
            }
            if (this.ignition_trim != null) {
                data.ignition_trim = this.ignition_trim;
            }
            if (this.idle_rpm != null) {
                data.idle_rpm = this.idle_rpm;
            }
            if (this.rev_limit != null) {
                data.rev_limit = this.rev_limit;
            }
            if (this.temp_compensation != null) {
                data.temp_compensation = this.temp_compensation;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.fuel_trim != 0)
                writer.writeDouble(1, this.fuel_trim);
            if (this.ignition_trim != 0)
                writer.writeDouble(2, this.ignition_trim);
            if (this.idle_rpm != 0)
                writer.writeDouble(3, this.idle_rpm);
            if (this.rev_limit != 0)
                writer.writeDouble(4, this.rev_limit);
            if (this.temp_compensation != false)
                writer.writeBool(5, this.temp_compensation);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ECUSettings {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ECUSettings();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.fuel_trim = reader.readDouble();
                        break;
                    case 2:
                        message.ignition_trim = reader.readDouble();
                        break;
                    case 3:
                        message.idle_rpm = reader.readDouble();
                        break;
                    case 4:
                        message.rev_limit = reader.readDouble();
                        break;
                    case 5:
                        message.temp_compensation = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ECUSettings {
            return ECUSettings.deserialize(bytes);
        }
    }
    export class UpdateStatus extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            success?: boolean;
            message?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("success" in data && data.success != undefined) {
                    this.success = data.success;
                }
                if ("message" in data && data.message != undefined) {
                    this.message = data.message;
                }
            }
        }
        get success() {
            return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
        }
        set success(value: boolean) {
            pb_1.Message.setField(this, 1, value);
        }
        get message() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set message(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            success?: boolean;
            message?: string;
        }): UpdateStatus {
            const message = new UpdateStatus({});
            if (data.success != null) {
                message.success = data.success;
            }
            if (data.message != null) {
                message.message = data.message;
            }
            return message;
        }
        toObject() {
            const data: {
                success?: boolean;
                message?: string;
            } = {};
            if (this.success != null) {
                data.success = this.success;
            }
            if (this.message != null) {
                data.message = this.message;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.success != false)
                writer.writeBool(1, this.success);
            if (this.message.length)
                writer.writeString(2, this.message);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UpdateStatus {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UpdateStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.success = reader.readBool();
                        break;
                    case 2:
                        message.message = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UpdateStatus {
            return UpdateStatus.deserialize(bytes);
        }
    }
}
